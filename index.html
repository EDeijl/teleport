<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<!-- Place this tag in your head or just before your close body tag. -->
<script async defer src="https://buttons.github.io/buttons.js"></script>
<h1>
Teleport - How to write a small, useful command line application in Haskell
</h1>
<p><a class="github-button" href="https://github.com/bollu/teleport" data-icon="octicon-star" data-style="mega" data-count-href="/bollu/teleport/stargazers" data-count-api="/repos/bollu/teleport#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star bollu/teleport on GitHub">Star</a></p>
<p><a class="github-button" href="https://github.com/bollu/teleport/fork" data-icon="octicon-repo-forked" data-style="mega" data-count-href="/bollu/teleport/network" data-count-api="/repos/bollu/teleport#forks_count" data-count-aria-label="# forks on GitHub" aria-label="Fork bollu/teleport on GitHub">Fork</a></p>
<p>We're going to build a command line application called <code>teleport</code>, It allows people to add &quot;warp points&quot; to navigate the file system. These can be added, deleted, listed, and goto'd.</p>
<p>We will be using the libraries:</p>
<ul>
<li><code>optparse-applicative</code>: parsing command line arguments</li>
<li><code>Aeson</code>: reading/writing <code>JSON</code></li>
<li><code>Turtle</code>: writing &quot;shell&quot;-y code for files and directories</li>
<li><code>ANSI</code>: emit colors in the console</li>
<li><code>Text</code> and <code>Bytestring</code>: forced to use these because of <code>Aeson</code>, <code>Filepath</code></li>
</ul>
<h3>
Demo
</h3>
<script type="text/javascript"
         src="https://asciinema.org/a/a0rzkn428t6mrnvzquc5fqoyr.js" 
        id="asciicast-a0rzkn428t6mrnvzquc5fqoyr" async></script>
<h3>
Intended audience
</h3>
<p>The indented audience are those who are comfortable with</p>
<ul>
<li>Functor, Applicative, Monad and <code>do</code> notation</li>
<li><code>IO</code> (no other monads required)</li>
<li>general haskell patterns</li>
</ul>
<p>You will learn to use Haskell libraries, and put them together to build something tangible.</p>
<h3>
Getting the code
</h3>
<p><a href="https://github.com/bollu/teleport">The code is available at the repository here (link)</a>.</p>
<p>To use the tutorial, a handy way of downloading and building <code>teleport</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone https://github.com/bollu/teleport.git <span class="kw">&amp;&amp;</span> <span class="kw">cd</span> teleport <span class="kw">&amp;&amp;</span> <span class="kw">cabal</span> build <span class="kw">&amp;&amp;</span> <span class="kw">cabal</span> install teleport</code></pre></div>
<p>To use the <code>teleport</code> wrapper you will need, run</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> source <span class="kw">`pwd`</span>/teleport.sh <span class="kw">&gt;&gt;</span> ~/.bashrc</code></pre></div>
<p>change <code>~/.bashrc</code> to the correct shell needed</p>
<h3>
Teleport's commands
</h3>
<h4>
<code>tp add  &lt;warpname&gt; [warppath]</code>
</h4>
<p>add a &quot;warp point&quot; that allows us to come back to the folder.</p>
<p>the default &quot;warp path&quot; is the current folder.</p>
<h6>
Example Usage
</h5>
<pre><code> # by default, current working directory is used
~/play/teleport-haskell$ tp add teleport-hs
creating teleport point:

teleport-hs /Users/bollu/play/teleport-haskell/

 # on providing the path to a teleport point, that path is used
~/play/teleport-haskell$ tp add sf ~/play/software-foundations
creating teleport point:

sf  /Users/bollu/play/software-foundations
</code></pre>
<h4>
<code>tp list</code>
</h4>
<p>list all warp points</p>
<h6>
Example Usage
</h6>
<pre><code>~/play/teleport-haskell$ tp list
teleport points: (total 3)
se  /Users/bollu/play/se/
sf  /Users/bollu/play/software-foundations/
tp  /Users/bollu/prog/teleport-haskell/</code></pre>
<h4>
<code>tp goto &lt;warp point&gt;</code>
</h4>
<p>go to the warp point. This is complicated, since we are not allowed to change the working directory of the shell. So, we will write a simple shell script wrapper around teleport.</p>
<p>The shell script is called <code>teleport.sh</code></p>
<h6>
Example Usage
</h6>
<pre><code>~$ tp goto tp
~/p/teleport-haskell$</code></pre>
<p>our current working directory changed and became the <code>teleport-haskell</code> folder</p>
<h4>
<code>tp remove &lt;warp point&gt;</code>
</h4>
<p>Remove an existing warp point.</p>
<h6>
Example Usage
</h6>
<pre><code>~/play/teleport-haskell$ tp remove teleport-hs
removed teleport point [teleport-hs]</code></pre>
<h2>
Reading the Code
</h2>
<p>Let's start reading the code, and learn about the libraries as we go along First thing's first, let us get the MIT license out of the way.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">--Copyright (c) 2015 Siddharth Bhat</span>

<span class="co">--Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="co">--a copy of this software and associated documentation files (the &quot;Software&quot;)</span>
<span class="co">--to deal in the Software without restriction, including without limitation the</span>
<span class="co">--rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span>
<span class="co">--sell copies of the Software, and to permit persons to whom the Software is</span>
<span class="co">--furnished to do so, subject to the following conditions:</span>

<span class="co">-- The above copyright notice and this permission notice shall</span>
<span class="co">-- be included in all copies or substantial portions of the Software.</span>

<span class="co">--THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="co">--OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="co">--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="co">--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="co">--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="co">--FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="co">--OTHER DEALINGS IN THE SOFTWARE.</span></code></pre></div>
<p>The interesting code starts from here.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE RecordWildCards #-}</span></code></pre></div>
<p><code>OverloadedStrings</code> allows us to freely write code in &quot; and have it be treated as String or Data.Text depending on context. It's a handy extension to have around.</p>
<p><code>RecordWildCards</code> is more interesting, and I'll describe it in more detail when we get to it</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Turtle</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">FilePath</span>)
<span class="kw">import </span><span class="dt">Filesystem.Path.CurrentOS</span> <span class="kw">as</span> <span class="dt">Path</span></code></pre></div>
<p><code>Turtle</code> is the haskell library we use to interact with the OS. It has a nice set of abstractions for dealing with OS specific stuff.</p>
<p>We choose to hide <code>FilePath</code> since <code>turtle</code> (the library for interfacing with the OS) has its own version of <code>FilePath</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Aeson</span> <span class="kw">as</span> <span class="dt">JSON</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span> ((.=), (.:))</code></pre></div>
<p>We use <code>Aeson</code> for reading and writing JSON files. We use JSON to store our settings</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Options.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.List</span></code></pre></div>
<p>These are our default imports of standard library stuff.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">T.Encoding</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">B</span></code></pre></div>
<p>We choose <code>Text</code> over <code>String</code> since the libraries that we use play along nicer with <code>Text</code>. <code>String</code> is just <code>[Char]</code> in haskell, which is quite inefficient since its <em>literally</em> a linked list. <code>Text</code> uses a more efficient representation of text. Text is used internally everywhere in the application to manipulate text.</p>
<p>We need <code>ByteString</code> to read and write JSON files onto the filesystem.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">System.Console.ANSI</span> <span class="kw">as</span> <span class="dt">ANSI</span></code></pre></div>
<p>the <code>ANSI</code> library is used for coloring our outputs.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">tpProgDesc ::</span> <span class="dt">String</span>
tpProgDesc <span class="fu">=</span> <span class="st">&quot;use teleport to quickly setup teleport points and move to these &quot;</span> <span class="fu">++</span>
               <span class="st">&quot;when needed&quot;</span>

<span class="ot">tpHeader ::</span> <span class="dt">String</span>
tpHeader <span class="fu">=</span> <span class="st">&quot;Teleport: move around your filesystem&quot;</span></code></pre></div>
<p>Strings that are used in our library for descriptions. I prefer to keep these as constants rather than hard-code them.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- the combined datatype representing all tp commands</span>
<span class="kw">data</span> <span class="dt">Command</span> <span class="fu">=</span> <span class="dt">CommandList</span> <span class="fu">|</span>
               <span class="dt">CommandAdd</span> <span class="dt">AddOptions</span> <span class="fu">|</span>
               <span class="dt">CommandRemove</span> <span class="dt">RemoveOptions</span> <span class="fu">|</span>
               <span class="dt">CommandGoto</span> <span class="dt">GotoOptions</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>The <code>Command</code> sum type represents the commands we can call on <code>teleport</code>, and we create options datatypes to store the options.</p>
<ul>
<li><code>AddOptions</code> needs the name of the warp point to add, and the path to the folder</li>
<li><code>RemoveOptions</code> needs the name of the warp point to remove</li>
<li><code>GotoOptions</code> needs the name of the warp point to go to</li>
<li><code>Command</code> is the data type that allows us to combine all of this information.</li>
</ul>
<p>our parser will return a <code>Command</code> that tells us what to do.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- options pased to &#39;tp add&#39;</span>
<span class="kw">data</span> <span class="dt">AddOptions</span> <span class="fu">=</span> <span class="dt">AddOptions</span> {
<span class="ot">    addname ::</span> <span class="dt">String</span>,
<span class="ot">    folderPath ::</span> FilePath
} <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p><code>tp add</code> needs the name of the warp point to add, and the path of the folder where it should get added to.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- options passed to &#39;tp remove&#39;</span>
<span class="kw">data</span> <span class="dt">RemoveOptions</span> <span class="fu">=</span> <span class="dt">RemoveOptions</span> {
<span class="ot">    removename ::</span> <span class="dt">String</span>
} <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- options parrsed to &#39;tp goto&#39;</span>
<span class="kw">data</span> <span class="dt">GotoOptions</span> <span class="fu">=</span> <span class="dt">GotoOptions</span> {
<span class="ot">    gotoname ::</span> <span class="dt">String</span>
} <span class="kw">deriving</span>(<span class="dt">Show</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | A version of &#39;execParser&#39; which shows full help on error.</span>
<span class="fu">--</span>
<span class="co">-- The regular &#39;execParser&#39; only prints usage on error, which doesn&#39;t</span>
<span class="co">-- include the options, subcommands, or mention of the help switch</span>
<span class="co">-- @--help@.</span>
<span class="ot">showHelpOnErrorExecParser ::</span> <span class="dt">ParserInfo</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
showHelpOnErrorExecParser <span class="fu">=</span> customExecParser (prefs showHelpOnError)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- command :: Command</span>
    command <span class="ot">&lt;-</span> showHelpOnErrorExecParser (info (helper <span class="fu">&lt;*&gt;</span> parseCommand)
                       (fullDesc  <span class="fu">&lt;&gt;</span>
                        progDesc tpProgDesc <span class="fu">&lt;&gt;</span>
                        header tpHeader))
    <span class="co">-- run :: IO ()</span>
    run command</code></pre></div>
<p>Let's unpack the types in <code>main</code>.</p>
<h5 class="codeheader">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span></code></pre></div>
</h5>
<p>this is our core <code>Parser</code> which we run using <code>showHelpOnErrorExecParser</code> which executes the parser, and shows an error in case the parser fails to execute. If the parse succeeds, it calls <code>run</code> which runs <code>command :: Command</code></p>
<h5 class="codeheader">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">helper ::</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a)</code></pre></div>
</h5>
<p><code>helper</code> takes any parser, and adds &quot;help&quot; as an option to it. We apply it to all parsers so <code>--help</code> works.</p>
<h5 class="codeheader">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">info ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">InfoMod</span> a <span class="ot">-&gt;</span> <span class="dt">ParserInfo</span> a</code></pre></div>
</h5>
<p><code>info</code> takes a parser and allows us to attach a <code>InfoMod</code> which adds help and display information to the parser</p>
<h5 class="codeheader">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fullDesc ::</span> <span class="dt">InfoMod</span> a
<span class="ot">progDesc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InfoMod</span> a
<span class="ot">header ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InfoMod</span> a</code></pre></div>
</h5>
<p>all of these allow us to attach <code>InfoMod</code> to a <code>Parser</code>, which changes the information that is printed with a <code>Parser</code>.</p>
<p>They have a <code>Monoid</code> instance, and the <code>&lt;&gt;</code> is the <code>mappend</code> operator that allows us to &quot;smash together&quot; two modifiers into one single modifier. One can think of <code>&lt;&gt;</code> as <code>++</code> for lists: it lets us collect two lists into one.</p>
<h5 class="codeheader">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">showHelpOnErrorExecParser</code></pre></div>
</h5>
<p>As explained above, it takes a parser and allows it to show help information when the parse fails. It executed the parser passed to it (<code>parseCommand</code>)</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseCommand <span class="fu">=</span> subparser <span class="fu">$</span>
    <span class="co">-- add command</span>
    (command
        <span class="st">&quot;add&quot;</span> <span class="co">-- command name</span>
        (info <span class="co">-- attach help information to the parser</span>
            (helper <span class="fu">&lt;*&gt;</span> parseAddCommand) <span class="co">-- core parser with the --help option</span>
            (fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;add a teleport point&quot;</span>) <span class="co">-- description of command (for info)</span>
        )
    )
    <span class="fu">&lt;&gt;</span> <span class="co">-- combine with the next command</span>

    <span class="co">-- list command</span>
    (command <span class="st">&quot;list&quot;</span>
        (info (helper <span class="fu">&lt;*&gt;</span> parseListCommand)
        (fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;list all teleport points&quot;</span>))
    ) <span class="fu">&lt;&gt;</span>
    <span class="co">-- remove command</span>
    (command <span class="st">&quot;remove&quot;</span>
        (info (helper <span class="fu">&lt;*&gt;</span> parseRemoveCommand)
        (fullDesc <span class="fu">&lt;&gt;</span>progDesc <span class="st">&quot;remove a teleport point&quot;</span>))
    ) <span class="fu">&lt;&gt;</span>
    <span class="co">-- goto command</span>
    (command <span class="st">&quot;goto&quot;</span>
        (info (helper <span class="fu">&lt;*&gt;</span> parseGotoCommand)
        (fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;go to a created teleport point&quot;</span>))
    )</code></pre></div>
<p>the <code>subparser</code> is a function that lets us create a <code>Parser</code> out of of a <code>command</code>. We smash the <code>command</code>s together with their monoid instance (<code>&lt;&gt;</code>).</p>
<p>The same use of <code>info</code>, <code>fullDesc</code>, <code>progDesc</code>, and <code>helper</code> is made as in <code>main</code> to attach information and help to the parser.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Command parsers</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="co">-- List</span>
<span class="co">-- ----</span>
<span class="co">-- $ tp list</span>
<span class="ot">parseListCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseListCommand <span class="fu">=</span> pure (<span class="dt">CommandList</span>)</code></pre></div>
<p>the parser needs no options (the <code>list</code> command takes no options), so we use <code class="sourceCode haskell">(<span class="ot">pure ::</span> a <span class="ot">-&gt;</span> f a)</code> to convert <code class="sourceCode haskell">(<span class="dt">CommandList</span><span class="ot"> ::</span> <span class="dt">Command</span>)</code> to <code class="sourceCode haskell">(pure <span class="dt">CommandList</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>)</code></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseAddCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseAddCommand <span class="fu">=</span> fmap <span class="co">-- :: (AddOptions -&gt; Command) -&gt; Parser AddOptions -&gt; Parser Command</span>
                   <span class="dt">CommandAdd</span> <span class="co">-- :: AddOptions -&gt; Command</span>
                   (liftA2 <span class="co">-- :: (String -&gt; FilePath -&gt; AddOptions) -&gt;</span>
                           <span class="co">--       Parser String -&gt; Parser FilePath -&gt; Parser AddOptions</span>
                        <span class="dt">AddOptions</span> <span class="co">-- :: String -&gt; FilePath -&gt; AddOptions</span>
                        tpnameParser <span class="co">-- :: Parser String</span>
                        folderParser <span class="co">-- :: Parser FilePath</span>
                   )</code></pre></div>
<p>we use <code class="sourceCode haskell">(liftA2 <span class="dt">AddOptions</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">AddOptions</span>)</code> and we pass it two parsers <code>tpNameParser</code> and <code>folderParser</code> (which will be defined below) to create a <code class="sourceCode haskell"><span class="dt">Parser</span> <span class="dt">AddOptions</span></code>.</p>
<p>we then convert <code class="sourceCode haskell">(<span class="dt">Parser</span> <span class="dt">AddOptions</span>)</code> to <code class="sourceCode haskell">(<span class="dt">Parser</span> <span class="dt">Command</span>)</code> by using <code class="sourceCode haskell">(fmap <span class="dt">CommandAdd</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">AddOptions</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Command</span>)</code></p>
<p>Till now, we were creating &quot;command&quot; parsers that parse things like</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tp</span> add
$ <span class="kw">tp</span> list</code></pre></div>
<p>Now, we need to learn how to parse <strong>options</strong>, such as:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tp</span> add <span class="kw">&lt;</span>warp point name<span class="kw">&gt;</span> ...</code></pre></div>
<p>to do this, the <strong>general function that is used is called <code class="sourceCode haskell">argument</code></strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> <span class="dt">ReadM</span> a <span class="ot">-&gt;</span> <span class="co">-- in general, &quot;can be read&quot;.</span>
            <span class="dt">Mod</span> <span class="dt">ArgumentFields</span> a <span class="ot">-&gt;</span> <span class="co">-- modifiers to a parser</span>
            <span class="dt">Parser</span> a</code></pre></div>
Let's read the code and then come back to the explanation with context:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Warp Name parser</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>
<span class="ot">tpnameParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
tpnameParser <span class="fu">=</span> argument  <span class="co">-- :: ReadM String -&gt; Mod ArgumentFields String -&gt; Parser String</span>
                  str <span class="co">-- :: ReadM String</span>
                  (metavar <span class="co">-- :: String -&gt; Mod ArgumentFields String</span>
                    <span class="st">&quot;NAME&quot;</span> <span class="fu">&lt;&gt;</span>
                  help <span class="co">-- :: String -&gt; Mod ArgumentFields String</span>
                    <span class="st">&quot;name of the teleport point for usage&quot;</span>) <span class="co">-- Mod ArgumentFields String</span></code></pre></div>
<h5>
Types
</h5>
<ul>
<li><p><code class="sourceCode haskell"><span class="dt">ReadM</span> a</code> is a way to &quot;read something in&quot;. We will start with the <code>ReadM</code> instance <code class="sourceCode haskell">(<span class="ot">str ::</span> <span class="dt">ReadM</span> <span class="dt">String</span>)</code> and use the <code>Functor</code> and <code>Monad</code> instance on <code>str</code> create new <code>ReadM</code> instances. <a href="https://hackage.haskell.org/package/optparse-applicative-0.13.0.0/docs/Options-Applicative-Builder.html#t:ReadM">For more on <code>ReadM</code>, click here</a></p></li>
<li><p><code class="sourceCode haskell"><span class="dt">Mod</span> <span class="dt">ArgumentFields</span> a</code> allows us to modify a <code>Parser</code> by providing it with modifiers. The modifiers have a <code>Monoid</code> instance, which allows us to smash them together with <code>mappend</code></p></li>
</ul>
<h5>
Code
</h5>
<ul>
<li>start with a <code class="sourceCode haskell"><span class="ot">str ::</span> <span class="dt">ReadM</span> <span class="dt">String</span></code></li>
<li>use the <code>metavar</code> option to give it a name</li>
<li>use the <code>help</code> option to give it a help string.</li>
</ul>
<h5>
Use of <code>metavar</code> &amp; <code>help</code>
</h5>
<pre><code>$ tp add --help
Usage: teleport-exe add NAME ...
 ...
Available options:
  ...
  NAME                     name of the teleport point for usage
  ...</code></pre>
<p>the <code>NAME</code> comes from the <code>metavar</code> option, and the help string comes from the <code>help</code> option</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- take a string, parse it into a folder path.</span>
<span class="co">-- if path does not exist, return an error</span>
<span class="ot">readFolderPath ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ReadM</span> FilePath
readFolderPath s <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> path <span class="fu">=</span> Path.fromText (T.pack s)
  <span class="kw">if</span> Path.valid path
      <span class="kw">then</span> return path
      <span class="kw">else</span> readerError (<span class="st">&quot;invalid path: &quot;</span> <span class="fu">++</span> (show path))</code></pre></div>
<p>We convert a <code>String</code> to a <code class="sourceCode haskell"><span class="dt">ReadM</span> FilePath</code>. Since <code class="sourceCode haskell"><span class="dt">ReadM</span></code> is a monad, it allows us to do error handling within it.</p>
<p>We return <code class="sourceCode haskell"><span class="dt">ReadM</span> FilePath</code> and not a <code class="sourceCode haskell">FilePath</code> to have the ability to return an error.</p>
<p>The <code class="sourceCode haskell">(<span class="ot">readerError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ReadM</span> a)</code> function allows to return an error string.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Folder Parser</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>
<span class="ot">folderParser ::</span> <span class="dt">Parser</span> FilePath
folderParser <span class="fu">=</span> argument
              (str <span class="co">-- :: ReadM String</span>
                <span class="fu">&gt;&gt;=</span>
               readFolderPath) <span class="co">-- :: String -&gt; ReadM FilePath</span>
              (value <span class="st">&quot;./&quot;</span>  <span class="fu">&lt;&gt;</span>
              metavar <span class="st">&quot;FOLDERPATH&quot;</span> <span class="fu">&lt;&gt;</span>
              help (<span class="st">&quot;path of the teleport folder to teleport to.&quot;</span> <span class="fu">++</span> 
                   <span class="st">&quot;By default, taken as current working directory&quot;</span>))</code></pre></div>
<p>Here, we look at how to build a more complex argument parser from the simple <code>str</code> argument.</p>
<ul>
<li><p>The composition of <code class="sourceCode haskell">(<span class="ot">str ::</span> <span class="dt">ReadM</span> <span class="dt">String</span>)</code> with <code class="sourceCode haskell">(<span class="ot">readFolderPath ::</span>  <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ReadM</span> FilePath)</code> using <code class="sourceCode haskell">(<span class="fu">&gt;&gt;=</span>)</code> gives us a function that takes a raw string, tries to parse it to a folder and fails if the parse fails.</p></li>
<li><p>The <code class="sourceCode haskell">(<span class="ot">value ::</span> <span class="dt">HasValue</span> f a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Mod</span> f a)</code> lets us define a default value to the &quot;folder&quot; option. We set the default to &quot;.&quot; (the current folder)</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseRemoveCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseRemoveCommand <span class="fu">=</span> fmap (<span class="dt">CommandRemove</span> <span class="fu">.</span> <span class="dt">RemoveOptions</span>) tpnameParser

<span class="ot">parseGotoCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseGotoCommand <span class="fu">=</span> fmap (<span class="dt">CommandGoto</span> <span class="fu">.</span> <span class="dt">GotoOptions</span>) tpnameParser</code></pre></div>
<ul>
<li><code class="sourceCode haskell"><span class="ot">tpnameParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></code> is used to parse names.</li>
<li><code class="sourceCode haskell">(<span class="dt">CommandRemove</span> <span class="fu">.</span> <span class="dt">RemoveOptions</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Command</span>)</code> converts <code class="sourceCode latex">String =RemoveOptions=&gt; RemoveOptions =CommandRemove=&gt; Command</code></li>
</ul>
<p>Similary, we created a <code class="sourceCode haskell">(<span class="dt">CommandGoto</span><span class="ot"> ::</span> <span class="dt">Command</span>)</code> with the same pipeline</p>
<p>We will start creating data types to hold the data for our program.</p>
<ul>
<li><code class="sourceCode haskell"><span class="dt">TpPoint</span></code> stores the information of a warp point.</li>
<li><code class="sourceCode haskell"><span class="dt">FromJSON</span></code> and <code class="sourceCode haskell"><span class="dt">ToJSON</span></code> typeclasses for <code>TpPoint</code> to allow it to store and retreive <code>JSON</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- an abstract entity representing a point to which we can tp to</span>
<span class="kw">data</span> <span class="dt">TpPoint</span> <span class="fu">=</span> <span class="dt">TpPoint</span> {
<span class="ot">    name ::</span> <span class="dt">String</span>,
<span class="ot">    absFolderPath ::</span> <span class="dt">String</span>
} <span class="kw">deriving</span> (<span class="dt">Show</span>)


<span class="kw">instance</span> <span class="dt">JSON.FromJSON</span> <span class="dt">TpPoint</span> <span class="kw">where</span>
     parseJSON (<span class="dt">JSON.Object</span> json) <span class="fu">=</span>
        liftA2 <span class="dt">TpPoint</span> (json <span class="fu">.:</span> <span class="st">&quot;name&quot;</span>)
                  (json <span class="fu">.:</span> <span class="st">&quot;absFolderPath&quot;</span>)</code></pre></div>
<ul>
<li><code class="sourceCode haskell"><span class="dt">FromJSON</span></code> is to convert a <code>JSON</code> object to a <code>TpPoint</code>.</li>
<li><p><code class="sourceCode haskell">(<span class="dt">Object</span> json)<span class="ot"> ::</span> <span class="dt">Value</span></code> is our parameter, and we need to creae a <code>TpPoint</code>.</p></li>
<li><p>We use the <code class="sourceCode haskell">(<span class="ot"> (.:) ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a)</code> operator, which when given a <code>JSON</code> <code>Object</code> and a key, gives us a <code class="sourceCode haskell"><span class="dt">Parser</span> a</code></p></li>
<li><p>the <code>Parser</code> has an applicative instance, so we lift our <code class="sourceCode haskell"><span class="dt">TpPoint</span></code> to the <code class="sourceCode haskell"><span class="dt">Parser</span></code> type with <code>liftA2</code></p></li>
<li><p>Here, we also see <code>RecordWildCards</code> (the extension) at play. It automatically &quot;unpacks&quot; the <code>TpPoint</code> for us, and we can directly access <code>name</code> and <code>absFoldeerPath</code></p></li>
<li><p>The syntax of <code class="sourceCode haskell">{<span class="fu">..</span>}</code> is used to denote that this declaration must be unpacked</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">JSON.ToJSON</span> <span class="dt">TpPoint</span> <span class="kw">where</span>
    toJSON (<span class="dt">TpPoint</span> {<span class="fu">..</span>}) <span class="fu">=</span>
        JSON.object [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name
                     ,<span class="st">&quot;absFolderPath&quot;</span> <span class="fu">.=</span> absFolderPath]</code></pre></div>
<ul>
<li><p><code class="sourceCode haskell">(<span class="ot">toJSON ::</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span>)</code> is used to create a JSON Value from an object <code>a</code>. For us, the <code class="sourceCode haskell">(a <span class="fu">~</span> <span class="dt">TpPoint</span>)</code>.</p></li>
<li><p>To create a <code>Value</code>, we use <code class="sourceCode haskell">(JSON.object<span class="ot"> :: object ::</span> [<span class="dt">Pair</span>] <span class="ot">-&gt;</span> <span class="dt">Value</span>)</code>. We give it an array of <code>Pair</code> objects and it creates a <code>Value</code>(JSON Value).</p></li>
<li><p>We use <code class="sourceCode haskell">(<span class="ot"> (.=) ::</span> <span class="dt">ToJSON</span> v <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (kv <span class="fu">~</span> <span class="dt">Pair</span>) )</code> to pair up a key with a <code>Value</code>. the <code class="sourceCode haskell"><span class="fu">.=</span></code> creates any <code>KeyValue</code>. We use it to create a <code>Pair</code>.</p></li>
</ul>
<p>We'll write a <code>TpData</code> class which stores all the warp points together in a list.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- the main data that is loaded from JSON</span>
<span class="kw">data</span> <span class="dt">TpData</span> <span class="fu">=</span> <span class="dt">TpData</span> {
<span class="ot">    tpPoints ::</span> [<span class="dt">TpPoint</span>]
} <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">JSON.FromJSON</span> <span class="dt">TpData</span> <span class="kw">where</span>
    parseJSON (<span class="dt">JSON.Object</span> v) <span class="fu">=</span>
        fmap <span class="dt">TpData</span> (v <span class="fu">.:</span> <span class="st">&quot;tpPoints&quot;</span>)

<span class="kw">instance</span> <span class="dt">JSON.ToJSON</span> <span class="dt">TpData</span> <span class="kw">where</span>
    toJSON(<span class="dt">TpData</span>{<span class="fu">..</span>}) <span class="fu">=</span> 
        JSON.object [<span class="st">&quot;tpPoints&quot;</span> <span class="fu">.=</span> tpPoints]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">defaultTpData ::</span> <span class="dt">TpData</span>
defaultTpData <span class="fu">=</span> <span class="dt">TpData</span> {
    tpPoints <span class="fu">=</span> []
}</code></pre></div>
<p>the <code>defaultTpData</code> represents the default <code>TpData</code> we will use if no warp data is found on execution.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">filePathToString ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span>
filePathToString <span class="fu">=</span> Path.encodeString

<span class="co">-- Data Loading</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">dieJSONParseError ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a
dieJSONParseError jsonFilePath err <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> errorstr <span class="fu">=</span> (<span class="st">&quot;parse error in: &quot;</span> <span class="fu">++</span> (show jsonFilePath) <span class="fu">++</span>
                    <span class="st">&quot;\nerror:------\n&quot;</span> <span class="fu">++</span> err)
    Turtle.die (T.pack errorstr)</code></pre></div>
<p>We write a quick function that errors out if the parse failed. To do this, we use <code>Turtle.die</code> that takes an error string and returns an <code>IO a</code> for failure.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">decodeTpData ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TpData</span>
decodeTpData jsonFilePath <span class="fu">=</span> <span class="kw">do</span>
    rawInput <span class="ot">&lt;-</span> B.readFile (filePathToString jsonFilePath)
    <span class="kw">let</span> jsonResult <span class="fu">=</span> JSON.eitherDecode&#39; rawInput

    <span class="kw">case</span> jsonResult <span class="kw">of</span>
      <span class="dt">Left</span> err <span class="ot">-&gt;</span> dieJSONParseError jsonFilePath err
      <span class="dt">Right</span> json <span class="ot">-&gt;</span> return json</code></pre></div>
<p>We use <code class="sourceCode haskell">JSON.eitherDecode&#39;<span class="ot"> ::</span>  <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</code> which takes a file path and returns an <code class="sourceCode haskell"><span class="dt">Either</span> <span class="dt">String</span> a</code> with the error in <code class="sourceCode haskell"><span class="dt">Left</span></code></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">createTpDataFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
createTpDataFile jsonFilePath <span class="fu">=</span> saveTpData jsonFilePath defaultTpData

<span class="ot">loadTpData ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TpData</span>
loadTpData jsonFilePath <span class="fu">=</span> <span class="kw">do</span>
    exists <span class="ot">&lt;-</span> (Turtle.testfile jsonFilePath)
    <span class="kw">if</span> exists <span class="kw">then</span>
        decodeTpData jsonFilePath
    <span class="kw">else</span>
       <span class="kw">do</span>
           createTpDataFile jsonFilePath
           return defaultTpData</code></pre></div>
<p>We try to load a file. If the file does not exist, we use <code class="sourceCode haskell"><span class="ot">defaultTpData ::</span> <span class="dt">TpData</span></code> We save this in the <code>createTpDataFile</code>, and then just return the default value. If we do get a value, then we return the parsed object.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">saveTpData ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">TpData</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
saveTpData jsonFilePath tpData <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> dataBytestring <span class="fu">=</span> JSON.encode tpData
    Turtle.touch jsonFilePath
    B.writeFile (filePathToString jsonFilePath) dataBytestring


<span class="ot">getTpDataPath ::</span> <span class="dt">IO</span> FilePath
getTpDataPath <span class="fu">=</span> <span class="kw">do</span>
    homeFolder <span class="ot">&lt;-</span> Turtle.home
    return <span class="fu">$</span> homeFolder <span class="fu">&lt;/&gt;</span> <span class="st">&quot;.tpdata&quot;</span></code></pre></div>
<p>Note the use of <code class="sourceCode haskell"><span class="dt">Turtle</span></code> for finding the home folder (<code>Turtle.home</code>) and to touch files (<code class="sourceCode haskell">Turtle.touch</code>). We concatenate <code>FilePath</code>s using <code class="sourceCode haskell">(<span class="fu">&lt;/&gt;</span><span class="ot"> ::</span> FilePath <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> FilePath)</code></p>
<p>We're now writing functions to error out nicely with colors, since everybody likes colors <code>:)</code></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Stream Helpers</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="co">-- set terminal to output error color</span>
<span class="ot">setErrorColor ::</span> <span class="dt">IO</span> ()
setErrorColor <span class="fu">=</span> ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="co">-- color to set</span>
                             <span class="dt">ANSI.Foreground</span> <span class="co">-- wherther foreground / background should be affected</span>
                            <span class="dt">ANSI.Vivid</span> <span class="co">-- use the &quot;vivid&quot; color versus the muted color</span>
                            <span class="dt">ANSI.Red</span> <span class="co">-- use red</span>
                            ]    </code></pre></div>
<ul>
<li><p><code class="sourceCode haskell"><span class="ot">setSGR ::</span> [<span class="dt">SGR</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code> lets us color the output. It takes an array of <code>SGR</code> (Select Graphic Rendition) objects, and applies them.</p></li>
<li><p>The <code>SGR</code> instance we use in <code>Teleport</code> are <code class="sourceCode haskell"><span class="dt">SetColor</span><span class="ot"> ::</span> <span class="dt">ConsoleLayer</span> <span class="dt">ColorIntensity</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">SGR</span></code> to add colors to our output</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- print a teleport point to stdout</span>
<span class="ot">tpPointPrint ::</span> <span class="dt">TpPoint</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
tpPointPrint tpPoint <span class="fu">=</span> <span class="kw">do</span>
    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Dull</span> <span class="dt">ANSI.White</span>]
    putStr (name tpPoint)
    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Blue</span>]    
    putStr <span class="st">&quot;\t&quot;</span>
    putStr (absFolderPath tpPoint)
    putStr <span class="st">&quot;\n&quot;</span>

<span class="co">-- error out that the given folder is not found</span>
<span class="ot">folderNotFoundError ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
folderNotFoundError path <span class="fu">=</span> <span class="kw">do</span>
    setErrorColor  
    <span class="kw">let</span> errorstr <span class="fu">=</span> T.pack (<span class="st">&quot;unable to find folder: &quot;</span> <span class="fu">++</span> (show path)) 
    Turtle.die errorstr

<span class="co">-- error out that folder is required, but path points</span>
<span class="co">-- to a file</span>
<span class="ot">needFolderNotFileError ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
needFolderNotFileError path <span class="fu">=</span> <span class="kw">do</span>
    setErrorColor
    <span class="kw">let</span> errorstr <span class="fu">=</span> T.pack (<span class="st">&quot;expected folder, not file: &quot;</span> <span class="fu">++</span> (show path)) 
    Turtle.die errorstr

<span class="ot">dieIfFolderNotFound ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dieIfFolderNotFound path <span class="fu">=</span> 
    <span class="kw">do</span>
        folderExists <span class="ot">&lt;-</span> Turtle.testdir path
        fileExists <span class="ot">&lt;-</span> Turtle.testfile path
        <span class="co">-- error checking</span>
        when fileExists (needFolderNotFileError path)
        unless folderExists (folderNotFoundError path)
       <span class="co">-- we know the folder exists</span>

<span class="co">-- error out that the teleport point already exists</span>
<span class="ot">dieTpPointExists ::</span> <span class="dt">TpPoint</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dieTpPointExists tpPoint  <span class="fu">=</span>  <span class="kw">do</span>
    setErrorColor
    putStrLn (<span class="st">&quot;teleport point &quot;</span> <span class="fu">++</span> (name tpPoint) <span class="fu">++</span> <span class="st">&quot; already exists:\n&quot;</span>)
    tpPointPrint tpPoint
    Turtle.die <span class="st">&quot;&quot;</span></code></pre></div>
<ul>
<li><code class="sourceCode haskell">Turtle.testdir<span class="ot"> ::</span> <span class="dt">MonadIO</span> io <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> io <span class="dt">Bool</span></code> allows us to check if the directory exists</li>
<li><code class="sourceCode haskell">Turtle.testfile<span class="ot"> ::</span> <span class="dt">MonadIO</span> io <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> io <span class="dt">Bool</span></code> lets us check if the file exists</li>
</ul>
<p>to check if the file and folder we care about exists.</p>
<p>Now, we're writing the <code>run</code> functions that tie everything up. <code>runAdd</code>:</p>
<ul>
<li>Checks that the teleport point is valid.</li>
<li>Checks that there is no other point of the same name.</li>
</ul>
if both these conditions hold true, it proceeds to create the point and save the data.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Add command runner</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">runAdd ::</span> <span class="dt">AddOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runAdd <span class="dt">AddOptions</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
    dieIfFolderNotFound folderPath
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath
    absFolderPath <span class="ot">&lt;-</span> Turtle.realpath folderPath

    <span class="kw">let</span> existingTpPoint <span class="fu">=</span> find (\tp <span class="ot">-&gt;</span> name tp <span class="fu">==</span> addname) (tpPoints tpData)
    <span class="kw">case</span> existingTpPoint <span class="kw">of</span>
        <span class="dt">Just</span> tpPoint <span class="ot">-&gt;</span> dieTpPointExists tpPoint
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
                        <span class="kw">let</span> newTpPoint <span class="fu">=</span> <span class="dt">TpPoint</span> {
                            name <span class="fu">=</span> addname,
                            absFolderPath <span class="fu">=</span> filePathToString absFolderPath
                        }

                        putStrLn <span class="st">&quot;creating teleport point: \n&quot;</span>
                        tpPointPrint newTpPoint

                        <span class="kw">let</span> newTpData <span class="fu">=</span> <span class="dt">TpData</span> {
                             tpPoints <span class="fu">=</span>  newTpPoint<span class="fu">:</span>(tpPoints tpData)   
                        }


                        saveTpData tpDataPath newTpData</code></pre></div>
We just iterate over all the teleport points, printing them one-by-one. Since we need an &quot;effect&quot; to happen for each <code>tpPoint</code> (it needs to be printed), we use <code class="sourceCode haskell">(<span class="ot">forM_ ::</span> (<span class="dt">Monad</span> m, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m ())</code> to achieve that.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- List Command</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">runList ::</span> <span class="dt">IO</span> ()
runList <span class="fu">=</span> <span class="kw">do</span>
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath
    <span class="kw">let</span> num_points <span class="fu">=</span> length <span class="fu">$</span> tpPoints tpData
    putStr <span class="st">&quot;teleport points: &quot;</span>

    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Blue</span>] 
    putStr <span class="fu">$</span> <span class="st">&quot;(total &quot;</span> <span class="fu">&lt;&gt;</span> (show num_points) <span class="fu">&lt;&gt;</span>  <span class="st">&quot;)\n&quot;</span>
    forM_ (tpPoints tpData) tpPointPrint</code></pre></div>
<p>To remove a teleport point:</p>
<ul>
<li>check if a teleport point with the name exists</li>
<li>If it does, filter it out and save the rest of the points</li>
<li>Otherwise, print an error</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- Remove Command</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">dieTpPointNotFound ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span><span class="dt">IO</span> ()
dieTpPointNotFound name <span class="fu">=</span> <span class="kw">do</span>
    setErrorColor
    <span class="kw">let</span> errorname <span class="fu">=</span> T.pack (name <span class="fu">++</span> <span class="st">&quot; tp point not found&quot;</span>)
    Turtle.die errorname

<span class="ot">runRemove ::</span> <span class="dt">RemoveOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runRemove <span class="dt">RemoveOptions</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath

    <span class="kw">let</span> wantedTpPoint <span class="fu">=</span> find (\tp <span class="ot">-&gt;</span> name tp <span class="fu">==</span> removename) (tpPoints tpData)
    <span class="kw">case</span> wantedTpPoint <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dieTpPointNotFound removename
        <span class="dt">Just</span> _ <span class="ot">-&gt;</span>  <span class="kw">do</span>
                    <span class="kw">let</span> newTpPoints <span class="fu">=</span> filter (\tp <span class="ot">-&gt;</span> name tp <span class="fu">/=</span> removename)
                                               (tpPoints tpData)
                    <span class="kw">let</span> newTpData <span class="fu">=</span> tpData {
                        tpPoints <span class="fu">=</span> newTpPoints
                    }

                    saveTpData tpDataPath newTpData
                    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Dull</span> <span class="dt">ANSI.White</span>]    
                    putStr <span class="st">&quot;removed teleport point [&quot;</span>
                    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Blue</span>]    
                    putStr removename
                    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Dull</span> <span class="dt">ANSI.White</span>]    
                    putStr <span class="st">&quot;]&quot;</span></code></pre></div>
<p>The proces of going to a teleport point is more complex, since our command (<code>teleport</code>) cannot change the working directory of another process (the shell).</p>
<p>So, we:</p>
<ul>
<li>run <code>teleport</code> within a shell script (<code>teleport.sh</code>)</li>
<li>return a special value (<code>2</code>) to the person who runs <code>teleport</code> (which is <code>teleport.sh</code>)</li>
<li>have <code>teleport.sh</code> execute a <code>cd</code> when it detects a return value of <code>2</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runGoto ::</span> <span class="dt">GotoOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runGoto <span class="dt">GotoOptions</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath

    <span class="kw">let</span> wantedTpPoint <span class="fu">=</span> find (\tp <span class="ot">-&gt;</span> name tp <span class="fu">==</span> gotoname) (tpPoints tpData)
    <span class="kw">case</span> wantedTpPoint <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dieTpPointNotFound gotoname
        <span class="dt">Just</span> tpPoint <span class="ot">-&gt;</span> <span class="kw">do</span>
                             Turtle.echo (T.pack (absFolderPath tpPoint))
                             Turtle.exit (<span class="dt">Turtle.ExitFailure</span> <span class="dv">2</span>) </code></pre></div>
<h5 class="codeheader">
<code>teleport.sh</code>
</h5>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"> <span class="co">#!/bin/bash</span>
 <span class="co"># teleport.sh</span>
<span class="kw">function</span><span class="fu"> tp()</span> <span class="kw">{</span>
    <span class="ot">OUTPUT=</span><span class="kw">`teleport-exe</span> <span class="ot">$@</span><span class="kw">`</span>
    <span class="co"># return code 2 is used to indicate that the shell script</span>
    <span class="co"># should use the output to warp to</span>
    <span class="kw">if [</span> <span class="ot">$?</span> <span class="ot">-eq</span> 2<span class="kw"> ]</span>
        <span class="kw">then</span> <span class="kw">cd</span> <span class="st">&quot;</span><span class="ot">$OUTPUT</span><span class="st">&quot;</span>
        <span class="kw">else</span> <span class="kw">echo</span> <span class="st">&quot;</span><span class="ot">$OUTPUT</span><span class="st">&quot;</span>
    <span class="kw">fi</span>
<span class="kw">}</span></code></pre></div>
<p>when <code>tp goto</code> succeeds, we print out the path to the output stream in Haskell and returns a return code of <code>2</code>. The shell script sees that the return code is <code>2</code>, so it runs a <code>cd</code> to the correct path</p>
<p>If <code>tp</code> returns any code other than <code>2</code>, the shell script echoes all the output to the screen.</p>
Now, we see all of it together in our <code>run</code> function which was called by <code>main</code> We simply pattern match on the command and then call the correct <code>run*</code> function
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
run command <span class="fu">=</span> 
    <span class="kw">case</span> command <span class="kw">of</span>
        <span class="dt">CommandAdd</span> addOpt <span class="ot">-&gt;</span> runAdd addOpt
        <span class="dt">CommandList</span> <span class="ot">-&gt;</span> runList
        <span class="dt">CommandRemove</span> removeOpt <span class="ot">-&gt;</span> runRemove removeOpt
        <span class="dt">CommandGoto</span> gotoOpt <span class="ot">-&gt;</span> runGoto gotoOpt</code></pre></div>
<h2>
Finale and Conclusion
</h2>
<p>Hopefully, this gave you a decent overview on how to combine libraries and use all of them in Haskell. If there are any bugs/comments, please do report them at <a href="https://github.com/bollu/teleport">the github repository</a></p>
</body>
</html>
