<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<h1>
Teleport - A haskell tutorial on Turtle, JSON and having fun
</h1>
<p>The command line application we are building is called teleport. It's a quick way to navigate the file system.</p>
<h3>
<pre> tp add <warpname> [warppath] </pre>
</h3>
<p>add a &quot;warp point&quot; that allows us to come back to the folder. By default, the current working directory is pointed by the name. An alternate path can be supplied</p>
<h3>
<pre> tp list </pre>
</h3>
<p>list all warp points</p>
<h3>
tp goto <warp point>
</h3>
go to the warp point. This is complicated, since we are not allowed to change the working directory of the shell. So, we will write a simple shell script wrapper around
<pre> teleport </pre>
<p>.</p>
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<p>First thing's first, let us get the MIT license out of the way.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">--Copyright (c) 2015 Siddharth Bhat</span>

<span class="co">--Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="co">--a copy of this software and associated documentation files (the &quot;Software&quot;)</span>
<span class="co">--to deal in the Software without restriction, including without limitation the</span>
<span class="co">--rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span>
<span class="co">--sell copies of the Software, and to permit persons to whom the Software is</span>
<span class="co">--furnished to do so, subject to the following conditions:</span>

<span class="co">-- The above copyright notice and this permission notice shall</span>
<span class="co">-- be included in all copies or substantial portions of the Software.</span>

<span class="co">--THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="co">--OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="co">--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="co">--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="co">--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="co">--FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="co">--OTHER DEALINGS IN THE SOFTWARE.</span></code></pre></div>
<h2 id="haskell-extensions">Haskell Extensions</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="st">#!/usr/bin/env stack</span></code></pre></div>
<p><code>OverloadedStrings</code> allows us to freely write code in &quot; and have it be treated as String or Data.Text depending on context. It's a handy extension to have around.</p>
<code>RecordWildCards</code> is more interesting, and I'll describe it in more detail when we get to it
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE RecordWildCards #-}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">FilePath</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">T.Encoding</span>

<span class="kw">import </span><span class="dt">Options.Applicative</span>
<span class="kw">import </span><span class="dt">Filesystem.Path.CurrentOS</span> <span class="kw">as</span> <span class="dt">Path</span>

<span class="kw">import qualified</span> <span class="dt">Turtle</span>

<span class="kw">import qualified</span> <span class="dt">Data.Aeson</span> <span class="kw">as</span> <span class="dt">JSON</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span> ((.=), (.:))

<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">B</span>

<span class="kw">import qualified</span> <span class="dt">System.Console.ANSI</span> <span class="kw">as</span> <span class="dt">ANSI</span>


<span class="kw">import </span><span class="dt">Debug.Trace</span></code></pre></div>
Explain main in this codebase.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">tpProgDesc ::</span> <span class="dt">String</span>
tpProgDesc <span class="fu">=</span> <span class="st">&quot;use teleport to quickly setup teleport points and move to these &quot;</span> <span class="fu">++</span>
               <span class="st">&quot;when needed&quot;</span>

<span class="ot">tpHeader ::</span> <span class="dt">String</span>
tpHeader <span class="fu">=</span> <span class="st">&quot;Teleport: move around your filesystem&quot;</span>



<span class="co">-- | A version of &#39;execParser&#39; which shows full help on error.                </span>
<span class="co">--                                                                            </span>
<span class="co">-- The regular &#39;execParser&#39; only prints usage on error, which doesn&#39;t         </span>
<span class="co">-- include the options, subcommands, or mention of the help switch            </span>
<span class="co">-- @--help@.                                                                  </span>
<span class="ot">showHelpOnErrorExecParser ::</span> <span class="dt">ParserInfo</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
showHelpOnErrorExecParser <span class="fu">=</span> customExecParser (prefs showHelpOnError)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> 
    command <span class="ot">&lt;-</span> showHelpOnErrorExecParser (info (helper <span class="fu">&lt;*&gt;</span> parseCommand)
                       (fullDesc  <span class="fu">&lt;&gt;</span>
                        progDesc tpProgDesc <span class="fu">&lt;&gt;</span>
                        header tpHeader))
    run command</code></pre></div>
<p>Explain how parsers work in <code>optparse-applicative</code> and how to compose them</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseCommand <span class="fu">=</span> subparser
    <span class="co">-- add command</span>
    ((command <span class="st">&quot;add&quot;</span> (info (helper <span class="fu">&lt;*&gt;</span> parseAddCommand) (fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;add a teleport point&quot;</span>))) <span class="fu">&lt;&gt;</span>
    <span class="co">-- list command</span>
    (command <span class="st">&quot;list&quot;</span>
        (info (helper <span class="fu">&lt;*&gt;</span> parseListCommand) (fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;list all teleport points&quot;</span>))) <span class="fu">&lt;&gt;</span>
    <span class="co">-- remove command</span>
    (command <span class="st">&quot;remove&quot;</span>
        (info (helper <span class="fu">&lt;*&gt;</span> parseRemoveCommand) (fullDesc <span class="fu">&lt;&gt;</span>progDesc <span class="st">&quot;remove a teleport point&quot;</span>))) <span class="fu">&lt;&gt;</span>
    <span class="co">-- goto command</span>
    (command <span class="st">&quot;goto&quot;</span>
        (info (helper <span class="fu">&lt;*&gt;</span> parseGotoCommand) (fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;go to a created teleport point&quot;</span>))))

<span class="co">-- Common parsers</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>
<span class="ot">readFolderPath ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ReadM</span> FilePath
readFolderPath s <span class="fu">=</span> T.pack s <span class="fu">|&gt;</span> 
                 Path.fromText <span class="fu">|&gt;</span> 
                 (\path <span class="ot">-&gt;</span> <span class="kw">if</span> Path.valid path
                     <span class="kw">then</span> return path
                     <span class="kw">else</span> readerError (<span class="st">&quot;invalid path: &quot;</span> <span class="fu">++</span> (show path)))


<span class="ot">tpnameParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
tpnameParser <span class="fu">=</span> argument str
                  (metavar <span class="st">&quot;NAME&quot;</span> <span class="fu">&lt;&gt;</span>
                  help <span class="st">&quot;name of the teleport point for usage&quot;</span>)


<span class="co">-- Command parsers</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">parseAddCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseAddCommand <span class="fu">=</span>  
    <span class="dt">CommandAdd</span> <span class="fu">&lt;$&gt;</span> (<span class="dt">AddOptions</span> <span class="fu">&lt;$&gt;</span>  tpnameParser <span class="fu">&lt;*&gt;</span> folderParser) <span class="kw">where</span>
        folderParser <span class="fu">=</span> argument
                     (str <span class="fu">&gt;&gt;=</span> readFolderPath)
                     (value <span class="st">&quot;./&quot;</span>  <span class="fu">&lt;&gt;</span>
                      metavar <span class="st">&quot;FOLDERPATH&quot;</span> <span class="fu">&lt;&gt;</span>
                      help <span class="st">&quot;path of the teleport folder to teleport to. By default, taken as current working directory&quot;</span>)

<span class="ot">parseListCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseListCommand <span class="fu">=</span> pure (<span class="dt">CommandList</span> <span class="dt">ListOptions</span>)

<span class="ot">parseRemoveCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseRemoveCommand <span class="fu">=</span> <span class="dt">CommandRemove</span> <span class="fu">&lt;$&gt;</span> (<span class="dt">RemoveOptions</span> <span class="fu">&lt;$&gt;</span> tpnameParser)

<span class="ot">parseGotoCommand ::</span> <span class="dt">Parser</span> <span class="dt">Command</span>
parseGotoCommand <span class="fu">=</span> <span class="dt">CommandGoto</span> <span class="fu">&lt;$&gt;</span> (<span class="dt">GotoOptions</span> <span class="fu">&lt;$&gt;</span> tpnameParser)</code></pre></div>
<p>We're creating <code>Options</code> datatypes to store the options.</p>
<ul>
<li><code>ListOptions</code> stores the options that listing will have (which are none)</li>
<li><code>AddOptions</code> needs the name of the warp point to add, and the path to the folder</li>
<li><code>RemoveOptions</code> needs the name of the warp point to remove</li>
<li><code>GotoOptions</code> needs the name of the warp point to go to</li>
<li><code>Command</code> is the data type that allows us to combine all of this information.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- options passed to &#39;tp list&#39;</span>
<span class="kw">data</span> <span class="dt">ListOptions</span> <span class="fu">=</span> <span class="dt">ListOptions</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- options pased to &#39;tp add&#39;</span>
<span class="kw">data</span> <span class="dt">AddOptions</span> <span class="fu">=</span> <span class="dt">AddOptions</span> {
<span class="ot">    addname ::</span> <span class="dt">String</span>,
<span class="ot">    folderPath ::</span> FilePath
} <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- options passed to &#39;tp remove&#39;</span>
<span class="kw">data</span> <span class="dt">RemoveOptions</span> <span class="fu">=</span> <span class="dt">RemoveOptions</span> {
<span class="ot">    removename ::</span> <span class="dt">String</span>
} <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- options parrsed to &#39;tp goto&#39;</span>
<span class="kw">data</span> <span class="dt">GotoOptions</span> <span class="fu">=</span> <span class="dt">GotoOptions</span> {
<span class="ot">    gotoname ::</span> <span class="dt">String</span>
} <span class="kw">deriving</span>(<span class="dt">Show</span>)
<span class="co">-- the combined datatype representing all tp commands</span>
<span class="kw">data</span> <span class="dt">Command</span> <span class="fu">=</span> <span class="dt">CommandList</span> <span class="dt">ListOptions</span> <span class="fu">|</span>
               <span class="dt">CommandAdd</span> <span class="dt">AddOptions</span> <span class="fu">|</span>
               <span class="dt">CommandRemove</span> <span class="dt">RemoveOptions</span> <span class="fu">|</span>
               <span class="dt">CommandGoto</span> <span class="dt">GotoOptions</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>This is our program representation. The <code>TpPoint</code> class stores the information of a warp point.</p>
<p>We will implement the <code>FromJSON</code> and <code>ToJSON</code> typeclasses for both to allow us to save these as JSON files</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- an abstract entity representing a point to which we can tp to</span>
<span class="kw">data</span> <span class="dt">TpPoint</span> <span class="fu">=</span> <span class="dt">TpPoint</span> {
<span class="ot">    name ::</span> <span class="dt">String</span>,
<span class="ot">    absFolderPath ::</span> <span class="dt">String</span>
} <span class="kw">deriving</span> (<span class="dt">Show</span>)


<span class="kw">instance</span> <span class="dt">JSON.FromJSON</span> <span class="dt">TpPoint</span> <span class="kw">where</span>
     parseJSON (<span class="dt">JSON.Object</span> v) <span class="fu">=</span>
        <span class="dt">TpPoint</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;name&quot;</span>
                  <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;absFolderPath&quot;</span>

<span class="kw">instance</span> <span class="dt">JSON.ToJSON</span> <span class="dt">TpPoint</span> <span class="kw">where</span>
    toJSON (<span class="dt">TpPoint</span> {<span class="fu">..</span>}) <span class="fu">=</span> 
        JSON.object [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name
                     ,<span class="st">&quot;absFolderPath&quot;</span> <span class="fu">.=</span> absFolderPath]</code></pre></div>
<p>The <code>TpData</code> class stores all the warp points together.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- the main data that is loaded from JSON </span>
<span class="kw">data</span> <span class="dt">TpData</span> <span class="fu">=</span> <span class="dt">TpData</span> {
<span class="ot">    tpPoints ::</span> [<span class="dt">TpPoint</span>]
} <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">JSON.FromJSON</span> <span class="dt">TpData</span> <span class="kw">where</span>
    parseJSON (<span class="dt">JSON.Object</span> v) <span class="fu">=</span>
        <span class="dt">TpData</span> <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;tpPoints&quot;</span>

<span class="kw">instance</span> <span class="dt">JSON.ToJSON</span> <span class="dt">TpData</span> <span class="kw">where</span>
    toJSON(<span class="dt">TpData</span>{<span class="fu">..</span>}) <span class="fu">=</span> 
        JSON.object [<span class="st">&quot;tpPoints&quot;</span> <span class="fu">.=</span> tpPoints]</code></pre></div>
<p>the <code>defaultTpData</code> represents the default <code>TpData</code> we will use if no warp data is found on execution.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">defaultTpData ::</span> <span class="dt">TpData</span>
defaultTpData <span class="fu">=</span> <span class="dt">TpData</span> {
    tpPoints <span class="fu">=</span> []
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">

<span class="co">-- flip function for ease of chaining computations</span>
<span class="ot">(|&gt;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
(<span class="fu">|&gt;</span>) <span class="fu">=</span> flip (<span class="fu">$</span>)


<span class="ot">filePathToString ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span>
filePathToString <span class="fu">=</span> Path.encodeString



<span class="co">-- Data Loading</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="co">-- parse tpPoint</span>

<span class="co">-- parse tpData</span>

<span class="ot">dieJSONParseError ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TpData</span>
dieJSONParseError jsonFilePath err <span class="fu">=</span> 
    (<span class="st">&quot;parse error in: &quot;</span> <span class="fu">++</span> (show jsonFilePath) <span class="fu">++</span>
    <span class="st">&quot;\nerror:------\n&quot;</span> <span class="fu">++</span> err) <span class="fu">|&gt;</span>
    T.pack <span class="fu">|&gt;</span>
    Turtle.die

<span class="ot">decodeTpData ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TpData</span>
decodeTpData jsonFilePath <span class="fu">=</span> <span class="kw">do</span>
    rawInput <span class="ot">&lt;-</span> B.readFile (filePathToString jsonFilePath)
    <span class="kw">let</span> jsonResult <span class="fu">=</span> JSON.eitherDecode&#39; rawInput  

    <span class="kw">case</span> jsonResult <span class="kw">of</span>
      <span class="dt">Left</span> err <span class="ot">-&gt;</span> dieJSONParseError jsonFilePath err
      <span class="dt">Right</span> json <span class="ot">-&gt;</span> return json

<span class="ot">createTpDataFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
createTpDataFile jsonFilePath <span class="fu">=</span> saveTpData jsonFilePath defaultTpData

<span class="ot">loadTpData ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TpData</span>
loadTpData jsonFilePath <span class="fu">=</span> <span class="kw">do</span>
    exists <span class="ot">&lt;-</span> (Turtle.testfile jsonFilePath)
    <span class="kw">if</span> exists <span class="kw">then</span>
        decodeTpData jsonFilePath
    <span class="kw">else</span>
       <span class="kw">do</span>
           createTpDataFile jsonFilePath
           return defaultTpData

<span class="ot">saveTpData ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">TpData</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
saveTpData jsonFilePath tpData <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> dataBytestring <span class="fu">=</span> JSON.encode tpData
    Turtle.touch jsonFilePath
    B.writeFile (filePathToString jsonFilePath) dataBytestring


<span class="ot">getTpDataPath ::</span> <span class="dt">IO</span> FilePath
getTpDataPath <span class="fu">=</span> <span class="kw">do</span>
    homeFolder <span class="ot">&lt;-</span> Turtle.home
    return <span class="fu">$</span> homeFolder <span class="fu">&lt;/&gt;</span> <span class="st">&quot;.tpdata&quot;</span>
<span class="co">-- Stream Helpers</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">setErrorColor ::</span> <span class="dt">IO</span> ()
setErrorColor <span class="fu">=</span> ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Red</span>]    


<span class="ot">tpPointPrint ::</span> <span class="dt">TpPoint</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
tpPointPrint tpPoint <span class="fu">=</span> <span class="kw">do</span>
    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Dull</span> <span class="dt">ANSI.White</span>]    
    putStr (name tpPoint)
    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Blue</span>]    
    putStr <span class="st">&quot;\t&quot;</span>
    putStr (absFolderPath tpPoint)
    putStr <span class="st">&quot;\n&quot;</span>

<span class="co">-- Add command runner</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">folderNotFoundError ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
folderNotFoundError path <span class="fu">=</span>
    setErrorColor <span class="fu">&gt;&gt;</span> 
    (<span class="st">&quot;unable to find folder: &quot;</span> <span class="fu">++</span> (show path)) <span class="fu">|&gt;</span>
    T.pack <span class="fu">|&gt;</span>
    Turtle.die

<span class="ot">needFolderNotFileError ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
needFolderNotFileError path <span class="fu">=</span> 
    setErrorColor <span class="fu">&gt;&gt;</span>
    (<span class="st">&quot;expected folder, not file: &quot;</span> <span class="fu">++</span> (show path)) <span class="fu">|&gt;</span>
    T.pack <span class="fu">|&gt;</span>
    Turtle.die

<span class="ot">dieIfFolderNotFound ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dieIfFolderNotFound path <span class="fu">=</span> 
    <span class="kw">do</span>
        folderExists <span class="ot">&lt;-</span> Turtle.testdir path
        fileExists <span class="ot">&lt;-</span> Turtle.testfile path
        <span class="co">-- error checking</span>
        when fileExists (needFolderNotFileError path)
        unless folderExists (folderNotFoundError path)
       <span class="co">-- we know the folder exists</span>

<span class="ot">dieTpPointExists ::</span> <span class="dt">TpPoint</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
dieTpPointExists tpPoint  <span class="fu">=</span>  <span class="kw">do</span>
    setErrorColor
    putStrLn (<span class="st">&quot;teleport point &quot;</span> <span class="fu">++</span> (name tpPoint) <span class="fu">++</span> <span class="st">&quot; already exists:\n&quot;</span>)
    tpPointPrint tpPoint
    Turtle.die <span class="st">&quot;&quot;</span>

<span class="ot">runAdd ::</span> <span class="dt">AddOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runAdd <span class="dt">AddOptions</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
    dieIfFolderNotFound folderPath
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath
    absFolderPath <span class="ot">&lt;-</span> Turtle.realpath folderPath
    
    <span class="kw">let</span> existingTpPoint <span class="fu">=</span> find (\tp <span class="ot">-&gt;</span> name tp <span class="fu">==</span> addname) (tpPoints tpData)
    <span class="kw">case</span> existingTpPoint <span class="kw">of</span>
        <span class="dt">Just</span> tpPoint <span class="ot">-&gt;</span> dieTpPointExists tpPoint
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
                        <span class="kw">let</span> newTpPoint <span class="fu">=</span> <span class="dt">TpPoint</span> {
                            name <span class="fu">=</span> addname,
                            absFolderPath <span class="fu">=</span> filePathToString absFolderPath
                        }
                      
                        putStrLn <span class="st">&quot;creating teleport point: \n&quot;</span>
                        tpPointPrint newTpPoint

                        <span class="kw">let</span> newTpData <span class="fu">=</span> <span class="dt">TpData</span> {
                             tpPoints <span class="fu">=</span>  newTpPoint<span class="fu">:</span>(tpPoints tpData)   
                        }
                        

                        saveTpData tpDataPath newTpData
    
<span class="co">-- List Command</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>


<span class="ot">runList ::</span> <span class="dt">ListOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runList <span class="dt">ListOptions</span> <span class="fu">=</span> <span class="kw">do</span>
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath
    <span class="kw">let</span> num_points <span class="fu">=</span> length <span class="fu">$</span> tpPoints tpData
    putStr <span class="st">&quot;teleport points: &quot;</span>

    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Blue</span>]    
    putStr <span class="fu">$</span> <span class="st">&quot;(total &quot;</span> <span class="fu">&lt;&gt;</span> (show num_points) <span class="fu">&lt;&gt;</span>  <span class="st">&quot;)\n&quot;</span>
    forM_ (tpPoints tpData) tpPointPrint
    

<span class="co">-- Remove Command</span>
<span class="co">-- &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>

<span class="ot">dieTpPointNotFound ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span><span class="dt">IO</span> ()
dieTpPointNotFound name <span class="fu">=</span> 
    setErrorColor <span class="fu">&gt;&gt;</span>
    (name <span class="fu">++</span> <span class="st">&quot; tp point not found&quot;</span>) <span class="fu">|&gt;</span>
    T.pack <span class="fu">|&gt;</span>
    Turtle.die

<span class="ot">runRemove ::</span> <span class="dt">RemoveOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runRemove <span class="dt">RemoveOptions</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath

    <span class="kw">let</span> wantedTpPoint <span class="fu">=</span> find (\tp <span class="ot">-&gt;</span> name tp <span class="fu">==</span> removename) (tpPoints tpData)
    <span class="kw">case</span> wantedTpPoint <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dieTpPointNotFound removename
        <span class="dt">Just</span> _ <span class="ot">-&gt;</span>  <span class="kw">do</span>
                    <span class="kw">let</span> newTpPoints <span class="fu">=</span> filter (\tp <span class="ot">-&gt;</span> name tp <span class="fu">/=</span> removename)
                                               (tpPoints tpData)
                    <span class="kw">let</span> newTpData <span class="fu">=</span> tpData {
                        tpPoints <span class="fu">=</span> newTpPoints
                    }

                    saveTpData tpDataPath newTpData
                    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Dull</span> <span class="dt">ANSI.White</span>]    
                    putStr <span class="st">&quot;removed teleport point [&quot;</span>
                    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Vivid</span> <span class="dt">ANSI.Blue</span>]    
                    putStr removename
                    ANSI.setSGR [<span class="dt">ANSI.SetColor</span> <span class="dt">ANSI.Foreground</span> <span class="dt">ANSI.Dull</span> <span class="dt">ANSI.White</span>]    
                    putStr <span class="st">&quot;]&quot;</span>
                    

<span class="ot">runGoto ::</span> <span class="dt">GotoOptions</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runGoto <span class="dt">GotoOptions</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
    tpDataPath <span class="ot">&lt;-</span> getTpDataPath
    tpData <span class="ot">&lt;-</span> loadTpData tpDataPath
    
    <span class="kw">let</span> wantedTpPoint <span class="fu">=</span> find (\tp <span class="ot">-&gt;</span> name tp <span class="fu">==</span> gotoname) (tpPoints tpData)
    <span class="kw">case</span> wantedTpPoint <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dieTpPointNotFound gotoname
        <span class="dt">Just</span> tpPoint <span class="ot">-&gt;</span> <span class="kw">do</span>
                             Turtle.echo (T.pack (absFolderPath tpPoint))
                             Turtle.exit (<span class="dt">Turtle.ExitFailure</span> <span class="dv">2</span>) 
      
<span class="ot">run ::</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
run command <span class="fu">=</span> 
    <span class="kw">case</span> command <span class="kw">of</span>
        <span class="dt">CommandAdd</span> addOpt <span class="ot">-&gt;</span> runAdd addOpt
        <span class="dt">CommandList</span> listOpt <span class="ot">-&gt;</span> runList listOpt
        <span class="dt">CommandRemove</span> removeOpt <span class="ot">-&gt;</span> runRemove removeOpt
        <span class="dt">CommandGoto</span> gotoOpt <span class="ot">-&gt;</span> runGoto gotoOpt
        other <span class="fu">@</span> _ <span class="ot">-&gt;</span> print other</code></pre></div>
</body>
</html>
